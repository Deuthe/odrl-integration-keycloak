#
# Copyright The Apache Software Foundation
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work regarding copyright ownership.  The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
apisix:
  node_listen: 9080
  enable_admin: false
  enable_debug: true

consumers:
  - username: odrl_user
    plugins:
      jwt-auth:
        key: a-secure-key-for-testing # This is the secret for validation
        algorithm: HS256

routes:
  - uri: /
    upstream_id: frontend_service

  - uri: /auth/token
    plugins:
      serverless-pre-function:
        phase: access
        functions:
          - |
            return function(conf, ctx)
                local core = require("apisix.core")
                local cjson = require("cjson.safe")
                local jwt = require("resty.jwt")

                -- 1. Get and parse the wallet data from the request body
                local request_body = core.request.get_body()
                if not request_body or request_body == "" then
                    core.response.exit(400, { message = "Missing request body" })
                    return
                end
                local body, err = cjson.decode(request_body)
                if err then
                    core.response.exit(400, { message = "Invalid JSON in request body" })
                    return
                end

                -- 2. Extract the required attributes
                local presented_attributes = body.credentials and body.credentials[1] and body.credentials[1].presentedAttributes
                if not presented_attributes then
                    core.response.exit(400, { message = "Missing presentedAttributes in credentials" })
                    return
                end
                local role = presented_attributes.role
                local gemeente = presented_attributes.gemeente
                if not role or not gemeente then
                    core.response.exit(400, { message = "Missing 'role' or 'gemeente' in presentedAttributes" })
                    return
                end

                -- 3. Manually create the JWT claims and sign the token
                local claims = {
                    role = role,
                    gemeente = gemeente,
                    exp = core.time.now() + 3600 -- Set token to expire in 1 hour
                }

                -- This secret MUST match the consumer's secret key
                local secret = "a-secure-key-for-testing"
                local jwt_token_str = jwt:sign(secret, { header = { alg = "HS256" }, payload = claims })

                -- 4. Return the new token to the user
                core.response.exit(200, { token = jwt_token_str })
            end
    upstream:
      # This is a dummy upstream, as the serverless function exits before proxying
      nodes:
        "127.0.0.1:1984": 1
      type: roundrobin

  - uri: /data/test
    plugins:
      jwt-auth: {}
    upstream_id: pap_service

upstreams:
  - id: pap_service
    nodes:
      "pap:3000": 1
    type: roundrobin

  - id: frontend_service
    nodes:
      "frontend:80": 1
    type: roundrobin
